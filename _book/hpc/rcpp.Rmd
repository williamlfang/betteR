---
title: "Rcpp：提供核动力"
author: William Fang
date: 2019-10-29
output: md_document
---

`R` 最早是出于教学的目的，由两位统计学教授 Ross Ihaka 和 Robert Gentleman 在新西兰大学共同发起创建。这就决定了 `R` 的天然基因是不具备 `CS` 的考究，即不过多的重视运行性能，而把重点放在快速验证想法。比如，`R` 属于解释型语言的范畴，不需要事先编译成机器码，只需要把需要处理的单行代码（或者单个代码块）传递给解释器（支持 `REPL`），就可以得到结果。从开发人员处理统计数据的角度看，这无疑是大大缩短了从想法到验证结果的的痛苦过程；但是，如果是重复执行某个步骤、大量调用某个函数，这就成为了一项瓶颈，毕竟边解释边运行需要消耗大量的运力，无法达到机器码那样的执行速度。

为了提升 `R` 的处理性能，我们常常绞尽脑汁，比如

-  使用向量化运算，尽量避免循环操作
- 使用并行计算，榨干机器的每一个 `cpu`
- 把执行的函数放入缓冲，避免重复调用

但是，无可避免的，以上的操作只是杯水车薪，无法从根本上解决 `R` 作为解释型语言的弱点。为了彻底解决这个问题，一个想法便是为 `R` 提供底层的代码支持，即绕开解释器、直接调用底层的 `c/c++` 执行运算，这样便可以大大的提升 `R` 的处理能力了。从开发的机制上看，`R` 本身是由 `S` 演变过来的，而最早的 `S` 语言又是使用 `c` 语言开发的，这意味着 `R` 实际上也是具备调用底层代码的能力。不过，直接编写允许调用底层 `c` 接口会比较麻烦，需要处理太多的技术细节。

为此，大牛 [Dirk Eddelbuettel](http://dirk.eddelbuettel.com/) 决定跳过 `c`，使用其高级版本——`c++` 为 `R` 提供调用底层的接口能力。这就是我们今天需要隆重介绍的主角：`Rcpp`。

<!--  -->
## 安装
直接使用 `CRAN` 安装即可

```{r}
install.packages("Rcpp")
```

完成后，可以使用命令载入


```{r}
library(Rcpp)
print('hello')
```


## 小例

## 对比

